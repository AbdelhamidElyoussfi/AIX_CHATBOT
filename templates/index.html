<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    
    <!-- Preload critical assets -->
    <link rel="preload" href="{{ url_for('static', filename='css/style.css') }}" as="style">
    <link rel="preload" href="{{ url_for('static', filename='js/main.js') }}" as="script">
    
    <!-- Optimize font loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
</head>
<body>
    <!-- Gradient background effect -->
    <div class="background-gradient"></div>
    
    <!-- Main container -->
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <div class="logo-area">
                    <a href="/" class="logo-link">
                        <div class="logo-icon">AIX</div>
                        <h1>Systems Assistant</h1>
                    </a>
                </div>
                <div class="header-controls">
                    <!-- User Profile Area -->
                    <div class="user-profile-area">
                        <div class="user-avatar-container">
                            <div class="user-avatar-placeholder">{{ user.username[0] }}</div>
                        </div>
                        <div class="user-info">
                            <span class="user-name">{{ user.username }}</span>
                            <a href="{{ url_for('logout') }}" class="logout-button">Logout</a>
                        </div>
                        
                    </div>
                </div>
            </div>
        </header>

        <!-- Main content area -->
        <main class="app-content">
            <!-- Sidebar with visual elements -->
            <aside class="app-sidebar">
                <div class="sidebar-content">
                    
                    
                    <!-- New Chat Button -->
                    <div class="new-chat-section">
                        <button id="new-chat-button" class="new-chat-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            New Chat
                        </button>
                    </div>
                    
                    <!-- Chat Sessions Section -->
                    <div class="chat-sessions-section">
                        <h3>Chat Sessions</h3>
                        <div id="chat-sessions-list" class="chat-sessions-list">
                            <!-- Chat sessions will be populated here -->
                            <div class="sessions-loading">Loading sessions...</div>
                        </div>
                    </div>
                    
                    <div class="sidebar-decoration">
                        <div class="decoration-element"></div>
                        <div class="decoration-element"></div>
                        <div class="decoration-element"></div>
                    </div>
                    <div class="sidebar-info">
                        <p>{{ description }}</p>
                    </div>
                </div>
            </aside>

            <!-- Mobile sidebar toggle -->
            <button id="sidebar-toggle" class="sidebar-toggle" aria-label="Toggle sidebar">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>

            <!-- Chat area -->
            <section class="chat-area">
                <div id="chat-messages" class="messages-container">
                    <!-- Messages will be inserted here -->
                </div>
                
                <!-- Input area -->
                <div class="input-area">
                    <form id="chat-form" class="message-form">
                        <textarea 
                            id="message-input" 
                            class="message-input"
                            placeholder="Ask anything about AIX systems..."
                            autocomplete="off"
                            rows="1"
                        ></textarea>
                        <button type="submit" class="send-button">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </form>
                </div>
            </section>
        </main>
    </div>

    <!-- Load optimized JS at the end of body for better performance -->
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
    <script>
        // Apply optimized container sizes
        document.documentElement.style.setProperty('--container-max-width', '900px');
        
        const chatMessages = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const messageInput = document.getElementById('message-input');
        const typingIndicator = document.getElementById('typing-indicator');
        const chatSessionsList = document.getElementById('chat-sessions-list');
        const newChatButton = document.getElementById('new-chat-button');
        const sendButton = document.querySelector('.send-button');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebar = document.querySelector('.app-sidebar');
        
        // Add controller for aborting fetch requests
        let currentController = null;
        
        // Flag for message editing
        let isEditingMessage = false;
        let messageBeingEdited = null;
        
        // Network status
        let isOnline = navigator.onLine;

        // Monitor network status
        window.addEventListener('online', function() {
            isOnline = true;
            showNetworkStatus(true);
        });
        
        window.addEventListener('offline', function() {
            isOnline = false;
            showNetworkStatus(false);
            
            // Abort any ongoing request when going offline
            if (currentController) {
                currentController.abort();
                currentController = null;
            }
        });
        
        // Show network status notification
        function showNetworkStatus(isOnline) {
            // Remove any existing network status message
            const existingStatus = document.querySelector('.network-status');
            if (existingStatus) {
                existingStatus.remove();
            }
            
            if (!isOnline) {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'network-status offline';
                statusDiv.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="1" y1="1" x2="23" y2="23"></line>
                        <path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path>
                        <path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path>
                        <path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path>
                        <path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path>
                        <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
                        <line x1="12" y1="20" x2="12.01" y2="20"></line>
                    </svg>
                    <span>You are offline. Some features may be unavailable.</span>
                `;
                
                document.body.appendChild(statusDiv);
                
                // Auto-hide after a few seconds
                setTimeout(() => {
                    statusDiv.classList.add('hiding');
                    setTimeout(() => statusDiv.remove(), 500);
                }, 5000);
            } else {
                // Show online status briefly
                const statusDiv = document.createElement('div');
                statusDiv.className = 'network-status online';
                statusDiv.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M5 12.55a11 11 0 0 1 14.08 0"></path>
                        <path d="M1.42 9a16 16 0 0 1 21.16 0"></path>
                        <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
                        <line x1="12" y1="20" x2="12.01" y2="20"></line>
                    </svg>
                    <span>Back online</span>
                `;
                
                document.body.appendChild(statusDiv);
                
                // Auto-hide after a few seconds
                setTimeout(() => {
                    statusDiv.classList.add('hiding');
                    setTimeout(() => statusDiv.remove(), 3000);
                }, 3000);
            }
        }

        // Toggle sidebar on mobile
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('visible');
        });
        
        // Close sidebar when clicking outside of it on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768 && 
                sidebar.classList.contains('visible') && 
                !sidebar.contains(e.target) && 
                e.target !== sidebarToggle) {
                sidebar.classList.remove('visible');
            }
        });

        // Format text with line breaks, lists, etc.
        function formatMessage(text) {
            // Remove "User Question" or similar meta text patterns
            text = text.replace(/^User Question\s*$/gmi, '');
            text = text.replace(/^Assistant\s*$/gmi, '');
            text = text.replace(/^User\s*$/gmi, '');
            
            // Remove lines that look like metadata, like timestamps or section markers
            text = text.replace(/^\d{1,2}:\d{1,2}(?::\d{1,2})?\s*(?:AM|PM)$/gmi, '');
            
            // Clean up any strange patterns with empty parentheses
            text = text.replace(/\s*\(\s*\)\s*/g, ' ');
            
            // Process code blocks first (```code```)
            text = text.replace(/```(?:(\w+)\n)?([\s\S]*?)```/g, function(match, language, code) {
                language = language || '';
                return `<div class="code-block-container">
                            <pre class="code-block ${language}"><code>${code.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>
                        </div>`;
            });
            
            // Convert bold text (**text**)
            text = text.replace(/\*\*([^*]+)\*\*/g, '<strong class="text-bold">$1</strong>');
            
            // Convert italic text (*text*)
            text = text.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em class="text-italic">$1</em>');
            
            // Convert markdown headers
            text = text.replace(/^# (.+)$/gm, '<h1 class="message-heading-1">$1</h1>');
            text = text.replace(/^## (.+)$/gm, '<h2 class="message-heading-2">$1</h2>');
            text = text.replace(/^### (.+)$/gm, '<h3 class="message-heading-3">$1</h3>');
            
            // Add content separators between sections (after headings)
            text = text.replace(/(<\/h[123]>)(?!\s*<h[123]|<\/div>)/g, '$1<div class="content-separator"></div>');
            
            // Clean up any "As per" or "According to" without references
            text = text.replace(/\b(as per|according to)([^a-zA-Z0-9])/gi, function(match, phrase, ending) {
                return phrase.charAt(0).toUpperCase() + phrase.slice(1) + ending;
            });
            
            // Convert bullet lists with various bullet characters (• ⚫ - * etc.)
            text = text.replace(/^[•⚫⦿◉○⦾*-]\s+([^\n]+)/gm, '<li class="bullet-item">$1</li>');
            
            // Convert numbered lists (1. Item)
            text = text.replace(/^\d+\.\s+([^\n]+)/gm, '<li class="numbered-item">$1</li>');
            
            // Wrap lists in <ul> or <ol> tags
            if (text.includes('<li class="numbered-item">')) {
                text = text.replace(
                    /(<li class="numbered-item">[^<]+<\/li>(\s*<li class="numbered-item">[^<]+<\/li>)*)/g, 
                    '<ol class="numbered-list">$1</ol>'
                );
            }
            
            if (text.includes('<li class="bullet-item">')) {
                text = text.replace(
                    /(<li class="bullet-item">[^<]+<\/li>(\s*<li class="bullet-item">[^<]+<\/li>)*)/g, 
                    '<ul class="bullet-list">$1</ul>'
                );
            }
            
            // Convert paragraphs (separated by blank lines)
            text = text.replace(/^([^<\n][^\n]+[^>\n])(?:\n{2,}|$)/gm, '<p class="message-paragraph">$1</p>');
            
            // Replace remaining linebreaks with <br>
            text = text.replace(/\n(?![<\n])/g, '<br>');
            
            // Highlight inline code
            text = text.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');
            
            // Final cleanup of any remaining strange characters or patterns
            text = text.replace(/\(\s*\)/g, '');
            text = text.replace(/\s{2,}/g, ' ');
            
            return text;
        }

        // Add timestamp to messages (for internal use only, not displayed)
        function getTimestamp() {
            const now = new Date();
            // Store full ISO timestamp for proper storage
            const isoTimestamp = now.toISOString();
            // Empty display time since timestamps are hidden
            const displayTime = "";
            
            return {
                iso: isoTimestamp,
                display: displayTime
            };
        }

        // Add message to the chat and auto-scroll to it
        function addMessage(content, isUser = false, id = null, timestamp = null) {
            // If we're editing, remove the message being edited
            if (isEditingMessage && messageBeingEdited && id) {
                messageBeingEdited.remove();
                isEditingMessage = false;
                messageBeingEdited = null;
            }
            
            // First remove any existing typing indicator
            hideTypingIndicator();
            
            const messageDiv = document.createElement('div');
            messageDiv.className = isUser ? 'message user-message' : 'message bot-message';
            
            // Add unique ID for message if provided
            if (id) {
                messageDiv.setAttribute('data-message-id', id);
            } else {
                messageDiv.setAttribute('data-message-id', Date.now().toString());
            }
            
            // Create message bubble
            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            
            // Create avatar
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            
            if (isUser) {
                // Check if user has a profile picture
                // User has no profile pic in simple auth mode
                avatar.innerHTML = `<div class="user-avatar">{{ user.username[0] }}</div>`;
            } else {
                avatar.innerHTML = `<div class="bot-avatar">AIX</div>`;
            }
            
            // Add message content
            const messageContent = document.createElement('div');
            messageContent.className = isUser ? 'message-content' : 'message-content response-content';
            
            // Add message text with formatting
            if (isUser) {
                messageContent.textContent = content;
            } else {
                messageContent.innerHTML = formatMessage(content);
            }
            
            // Get or use provided timestamp
            const timeObj = timestamp || getTimestamp();
            
            // Add timestamp (hidden from UI but still stored for data purposes)
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.style.display = 'none'; // Hide timestamp from UI
            timestampDiv.textContent = typeof timeObj === 'string' ? timeObj : timeObj.display;
            
            // Store full timestamp as data attribute for proper persistence
            if (typeof timeObj !== 'string' && timeObj.iso) {
                timestampDiv.setAttribute('data-iso-time', timeObj.iso);
            }
            
            // Assemble message
            messageBubble.appendChild(messageContent);
            messageBubble.appendChild(timestampDiv);
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageBubble);
            
            // Add to chat
            chatMessages.appendChild(messageDiv);
            
            // Smoothly scroll to the latest message
            scrollToLatestMessage();
            
            return messageDiv;
        }
        
        // Edit a message
        function editMessage(messageDiv) {
            const messageContent = messageDiv.querySelector('.message-content');
            const originalText = messageContent.textContent;
            
            // Set global edit state
            isEditingMessage = true;
            messageBeingEdited = messageDiv;
            
            // Fill input with message content
            messageInput.value = originalText;
            messageInput.focus();
            
            // Change send button to edit mode
            sendButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                    <polyline points="7 3 7 8 15 8"></polyline>
                </svg>
            `;
            
            // Visual indication of editing mode
            messageDiv.classList.add('editing');
            chatForm.classList.add('editing-mode');
        }
        
        // Delete a message and its response
        function deleteMessage(messageDiv) {
            if (!confirm('Are you sure you want to delete this message?')) {
                return;
            }
            
            // Find the next bot message (if any)
            let nextMessage = messageDiv.nextElementSibling;
            if (nextMessage && nextMessage.classList.contains('bot-message')) {
                // Also remove the bot response
                nextMessage.remove();
            }
            
            // Remove the user message
            messageDiv.remove();
            
            // Save updated chat to localStorage
            saveChatToLocalStorage();
        }
        
        // Function to scroll to the latest message
        function scrollToLatestMessage() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
            // For smoother animation effect
            setTimeout(() => {
                chatMessages.scrollTo({
                    top: chatMessages.scrollHeight,
                    behavior: 'smooth'
                });
            }, 50);
        }

        // Function to check if server is still responding during a long-running request
        async function checkServerConnectivity() {
            try {
                // Simple lightweight request to check server status
                const response = await fetch('/api/sessions', {
                    method: 'HEAD', // Just check headers, don't need the body
                    cache: 'no-store', // Don't use cache
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache'
                    }
                });
                
                return response.ok;
            } catch (error) {
                console.error('Server connectivity check failed:', error);
                return false;
            }
        }
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                document.body.classList.add('page-hidden');
                document.body.classList.remove('page-visible');
                
                // Only abort ongoing requests when explicitly configured to do so
                if (!preventAutoAbort && currentController) {
                    currentController.abort();
                    currentController = null;
                    console.log('Request aborted due to page visibility change');
                } else {
                    console.log('Request protected from automatic abort on visibility change');
                }
            } else {
                document.body.classList.add('page-visible');
                document.body.classList.remove('page-hidden');
            }
        });
        
        // Function to manually stop generation (connected to stop button)
        function stopGeneration() {
            if (currentController) {
                currentController.abort();
                currentController = null;
                console.log('Request manually aborted by user');
                
                // Hide typing indicator immediately
                hideTypingIndicator();
                
                // Reset send button immediately
                sendButton.classList.remove('loading');
                sendButton.classList.remove('stop-generation');
                sendButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                `;
                
                // Re-enable message input
                messageInput.disabled = false;
                messageInput.focus();
            }
        }
        
        // Function to show typing indicator as a message
        function showTypingIndicator() {
            // First remove any existing typing indicator
            hideTypingIndicator();
            
            // Create a message div for the typing indicator
            const typingMessageDiv = document.createElement('div');
            typingMessageDiv.className = 'message bot-message typing-message';
            typingMessageDiv.id = 'typing-indicator';
            
            // Create avatar
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.innerHTML = `<div class="bot-avatar">AIX</div>`;
            
            // Create message bubble
            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            
            // Add typing dots
            const dotsContainer = document.createElement('div');
            dotsContainer.className = 'typing-dots';
            dotsContainer.innerHTML = `
                <span class="dot"></span>
                <span class="dot" style="animation-delay: 0.2s; background-color: var(--accent-secondary);"></span>
                <span class="dot" style="animation-delay: 0.4s; background-color: var(--accent-tertiary);"></span>
            `;
            
            // Assemble message
            messageBubble.appendChild(dotsContainer);
            typingMessageDiv.appendChild(avatar);
            typingMessageDiv.appendChild(messageBubble);
            
            // Add to chat
            chatMessages.appendChild(typingMessageDiv);
            
            // Scroll to the typing indicator
            scrollToLatestMessage();
            
            return typingMessageDiv;
        }
        
        // Function to hide typing indicator
        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        // Basic implementation of sendMessage that won't auto-abort
        async function sendMessage(message) {
            let lastErrorDiv = null;
            
            try {
                // Abort any previous request if exists
                if (currentController) {
                    currentController.abort();
                }
                
                // Create a new controller for this request
                currentController = new AbortController();
                const signal = currentController.signal;
                
                // First remove any existing typing indicator to ensure proper order
                hideTypingIndicator();
                
                // Create and add user message with current timestamp
                const userTimestamp = getTimestamp();
                addMessage(message, true, null, userTimestamp);
                
                // Show typing indicator as a message and disable input
                // Add typing indicator AFTER user message
                showTypingIndicator();
                messageInput.disabled = true;
                
                // Change send button to stop button
                sendButton.classList.add('stop-generation');
                sendButton.disabled = false;
                sendButton.innerHTML = `
                    <span class="stop-indicator"></span>
                `;
                
                try {
                    // If we're at the root path with no session ID, we'll need to create one after getting a response
                    const isRootPathWithNoSession = window.location.pathname === '/' && !getCurrentSessionId();
                    
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            message,
                            user_timestamp: userTimestamp.iso // Send user timestamp to server
                        }),
                        signal // Attach the abort signal
                    });
                    
                    // Check if we got a successful response
                    if (response.ok) {
                        const data = await response.json();
                    
                        if (data && data.response) {
                            // Hide the typing indicator only after we have a response
                            hideTypingIndicator();
                            
                            // Create timestamp object (hidden from UI)
                            const timestamp = {
                                display: "",
                                iso: data.iso_timestamp || getTimestamp().iso
                            };
                            
                            // Add the response to the chat
                            addMessage(data.response, false, null, timestamp);
                            
                            // Save chat history to local storage for persistence
                            saveChatToLocalStorage();
                            
                            // Refresh chat sessions after new message
                            await loadChatSessions();
                            
                            // If we were at the root path with no session,
                            // update the URL to the newly created session
                            if (isRootPathWithNoSession && data.session_id) {
                                const newUrl = `/chat/${data.session_id}`;
                                window.history.pushState({}, '', newUrl);
                                console.log(`Created new chat session: ${data.session_id}, updated URL to ${newUrl}`);
                            }
                        } else {
                            // Hide typing indicator if we got an empty response
                            hideTypingIndicator();
                            throw new Error('Server returned an empty response');
                        }
                    } else {
                        // Hide typing indicator on error
                        hideTypingIndicator();
                        
                        // For error responses, first clone the response so we can try multiple reads
                        const responseClone = response.clone();
                        
                        // Try to parse as JSON first
                        try {
                            const errorData = await response.json();
                            throw new Error(errorData.error || `Server error: ${response.status}`);
                        } catch (jsonError) {
                            // If we can't parse as JSON, get the text content from the clone
                            try {
                                const errorText = await responseClone.text();
                                throw new Error(`Server error (${response.status}): ${errorText.substring(0, 100)}`);
                            } catch (textError) {
                                // If all else fails
                                throw new Error(`Server error (${response.status}): Unable to read response`);
                            }
                        }
                    }
                } catch (fetchError) {
                    // Hide the typing indicator only for abort errors or after showing an error message
                    if (fetchError.name === 'AbortError') {
                        hideTypingIndicator();
                        console.log('Request was aborted by user');
                    } else {
                        // This was another error, show retry button
                        console.error('Error during fetch:', fetchError);
                        const errorMessage = fetchError.message || 'Could not connect to the server';
                        lastErrorDiv = showRetryableError(errorMessage, message);
                        // Hide typing indicator after showing the error
                        hideTypingIndicator();
                    }
                }
            } finally {
                // Always clear the controller and reset UI
                currentController = null;
                resetUI();
            }
            
            return lastErrorDiv; // Return the error div if created
        }
        
        // Function to reset UI elements
        function resetUI() {
            // Hide typing indicator
            hideTypingIndicator();
            
            // Reset send button
            sendButton.classList.remove('loading');
            sendButton.classList.remove('stop-generation');
            sendButton.disabled = false;
            sendButton.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            
            // Re-enable message input
            messageInput.disabled = false;
            messageInput.focus();
        }
        
        // Add message to queue and process
        function queueMessage(message) {
            // Check if we're online before queuing
            if (!navigator.onLine) {
                // Show error message
                showRetryableError('You are currently offline. Your message will be sent when you reconnect.', message);
                return;
            }
            
            // Simple queue implementation - just send directly for now
            sendMessage(message);
        }

        // Handle keyboard events for the input
        messageInput.addEventListener('keydown', (e) => {
            // Enter key without shift should submit the form
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                chatForm.dispatchEvent(new Event('submit'));
            }
            
            // Shift+Enter should insert a new line
            if (e.key === 'Enter' && e.shiftKey) {
                // Let the default behavior happen (new line)
                
                // Auto-resize the input field to fit content
                setTimeout(() => {
                    messageInput.style.height = 'auto';
                    messageInput.style.height = (messageInput.scrollHeight) + 'px';
                }, 0);
            }
        });
        
        // Reset textarea height when it loses focus (optional)
        messageInput.addEventListener('blur', () => {
            messageInput.style.height = 'auto';
        });
        
        // Auto-resize input when content changes
        messageInput.addEventListener('input', () => {
            messageInput.style.height = 'auto';
            messageInput.style.height = (messageInput.scrollHeight) + 'px';
        });

        // Handle New Chat button
        newChatButton.addEventListener('click', () => {
            createNewSession();
        });

        // Add visual effects
        function createDecorativeElements() {
            const decorations = document.querySelectorAll('.decoration-element');
            decorations.forEach((el, i) => {
                el.style.animationDelay = `${i * 0.5}s`;
            });
        }
        
        // Disable abort-on-visibility-change behavior that's causing problems during rotation
        let preventAutoAbort = true; // Set to true to prevent automatic aborts on visibility change
        
        // Initialize
        window.addEventListener('load', () => {
            createDecorativeElements();
            
            // Set initial page visibility state
            if (document.visibilityState === 'visible') {
                document.body.classList.add('page-visible');
                } else {
                document.body.classList.add('page-hidden');
            }
            
            // Check if we have a session ID in the URL
            const urlParams = new URLSearchParams(window.location.search);
            const sessionIdFromUrl = urlParams.get('session');
            
            // If we're at the root path with no session parameter
            if (window.location.pathname === '/' && !sessionIdFromUrl) {
                // Just initialize the UI without loading chat history
                loadChatSessions(null, false);
                
                // Add welcome message only
                setTimeout(() => {
                    if (chatMessages.children.length === 0) {
                        addMessage('{{ initial_message }}');
                    }
                }, 300);
            } else {
                // Load chat sessions with history for non-root paths
                loadChatSessions(sessionIdFromUrl);
            }
            
            // Focus input
            messageInput.focus();
            
            // Add event to auto-focus input when clicked anywhere in chat area
            chatMessages.addEventListener('click', () => {
                // Only focus if not selecting text and not clicking buttons
                if (!window.getSelection().toString() && 
                    !event.target.closest('button') && 
                    !event.target.closest('a') &&
                    !isEditingMessage) {
                    messageInput.focus();
                }
            });
        });
        
        // Add a session item to the sessions list
        function addSessionItem(session, isActive = false) {
            const sessionItem = document.createElement('div');
            sessionItem.className = `session-item ${isActive ? 'active' : ''}`;
            sessionItem.setAttribute('data-session-id', session.id);
            
            // Format date
            const sessionDate = new Date(session.updated_at);
            const dateString = sessionDate.toLocaleDateString();
            
            sessionItem.innerHTML = `
                <div class="session-item-content">
                    <div class="session-title" title="${session.title}">${session.title}</div>
                    <div class="session-meta">
                        <span class="session-date">${dateString}</span>
                    </div>
                </div>
                <div class="session-actions">
                    <button class="session-delete-btn" title="Delete session">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6"></path>
                            <path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                        </svg>
                    </button>
                </div>
            `;
            
            // Add click event to load this session
            sessionItem.addEventListener('click', (e) => {
                // Don't switch if clicking delete button
                if (e.target.closest('.session-delete-btn')) {
                    return;
                }
                
                switchSession(session.id);
            });
            
            // Add delete event
            const deleteBtn = sessionItem.querySelector('.session-delete-btn');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteSession(session.id);
            });
            
            chatSessionsList.appendChild(sessionItem);
        }
        
        // Switch to a different chat session
        async function switchSession(sessionId) {
            try {
                // Cancel any ongoing request when switching chats
                if (currentController) {
                    currentController.abort();
                    currentController = null;
                }
                
                // Reset UI
                resetUI();
                
                // Clear messageQueue when switching sessions to prevent race conditions
                messageQueue = [];
                isProcessingMessage = false;
                
                // Update URL with session ID without reloading the page
                const url = new URL(window.location);
                url.searchParams.set('session', sessionId);
                window.history.pushState({}, '', url);
                
                const response = await fetch('/api/sessions/switch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ session_id: sessionId }),
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Update active session in UI
                    document.querySelectorAll('.session-item').forEach(item => {
                        item.classList.remove('active');
                        if (item.getAttribute('data-session-id') === sessionId) {
                            item.classList.add('active');
                        }
                    });
                    
                    // Save current session ID to localStorage
                    localStorage.setItem('current_session_id', sessionId);
                    
                    // Load messages for this session
                    loadChatHistory();
                } else {
                    console.error('Error switching session:', data.error);
                    showError('Failed to switch chat session', true);
                }
            } catch (error) {
                console.error('Error switching session:', error);
                showError('Failed to switch chat session', true);
            }
        }
        
        // Create a new chat session
        async function createNewSession(forceWelcome = false) {
            try {
                // Show loading state
                chatMessages.innerHTML = '<div class="loading-message">Creating new chat...</div>';
                
                // Clear messageQueue when creating new session
                messageQueue = [];
                isProcessingMessage = false;
                
                const response = await fetch('/api/sessions/new', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({}),
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Update URL with new session ID
                    const url = new URL(window.location);
                    url.searchParams.set('session', data.session_id);
                    window.history.pushState({}, '', url);
                    
                    // Get the current sessions to check if our new session was created
                    const sessionsResponse = await fetch('/api/sessions');
                    const sessionsData = await sessionsResponse.json();
                    
                    // Clear chat area
                    chatMessages.innerHTML = '';
                    
                    // Always add welcome message if forceWelcome is true
                    if (forceWelcome) {
                        addMessage('{{ initial_message }}');
                    } else {
                        // Add initial welcome message after a short delay
                        setTimeout(() => {
                            if (chatMessages.children.length === 0) {
                                addMessage('{{ initial_message }}');
                            }
                        }, 300);
                    }
                    
                    // Update the sessions list without creating a new session
                    // (to avoid infinite loop of session creation)
                    if (sessionsData.sessions.length > 0) {
                        // Clear existing sessions
                        chatSessionsList.innerHTML = '';
                        
                        // Add sessions to sidebar
                        sessionsData.sessions.forEach(session => {
                            addSessionItem(session, session.id === sessionsData.current_session_id);
                        });
                        
                        // Save sessions to localStorage
                        localStorage.setItem('chat_sessions', JSON.stringify(sessionsData.sessions));
                        localStorage.setItem('current_session_id', sessionsData.current_session_id);
                    }
                    
                    // Focus input
                    messageInput.focus();
                } else {
                    console.error('Error creating new session:', data.error);
                    showError('Failed to create new chat session', true);
                }
            } catch (error) {
                console.error('Error creating new session:', error);
                showError('Failed to create new chat session', true);
            }
        }
        
        // Delete a chat session
        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this chat session?')) {
                return;
            }
            
            try {
                // Get the current number of sessions to check if this is the last one
                const sessionsResponse = await fetch('/api/sessions');
                const sessionsData = await sessionsResponse.json();
                const isLastSession = sessionsData.sessions.length <= 1;
                
                // Clear chat area immediately to provide visual feedback
                chatMessages.innerHTML = '<div class="loading-message">Deleting chat session...</div>';
                
                // Clear messageQueue when deleting session
                messageQueue = [];
                isProcessingMessage = false;
                
                const response = await fetch('/api/sessions/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        session_id: sessionId,
                        is_last_session: isLastSession 
                    }),
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Remove deleted session from localStorage
                    removeSessionFromLocalStorage(sessionId);
                    
                    if (data.redirect_to_root) {
                        // Redirect to root for welcome page if deleting current session
                        window.location.href = '/';
                        return;
                    }
                    
                    if (data.create_new) {
                        // Wait a moment to ensure the deletion is complete
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Clear any existing chat content
                        chatMessages.innerHTML = '';
                        
                        // Create a new session with welcome message
                        await createNewSession(true);
                    } else {
                        // Refresh sessions list first
                        await loadChatSessions();
                        
                        // Update URL with new session ID if needed
                        const url = new URL(window.location);
                        if (data.current_session_id) {
                            url.searchParams.set('session', data.current_session_id);
                        } else {
                            url.searchParams.delete('session');
                        }
                        window.history.pushState({}, '', url);
                        
                        // Then load history for the current session
                        await loadChatHistory();
                    }
                } else {
                    console.error('Error deleting session:', data.error);
                    showError('Failed to delete chat session', true);
                }
            } catch (error) {
                console.error('Error deleting session:', error);
                showError('Failed to delete chat session', true);
            }
        }
        
        // Remove session from localStorage
        function removeSessionFromLocalStorage(sessionId) {
            try {
                localStorage.removeItem(`chat_history_${sessionId}`);
                
                // Update sessions list in localStorage
                const savedSessions = localStorage.getItem('chat_sessions');
                if (savedSessions) {
                    const sessions = JSON.parse(savedSessions);
                    const updatedSessions = sessions.filter(session => session.id !== sessionId);
                    localStorage.setItem('chat_sessions', JSON.stringify(updatedSessions));
                }
            } catch (error) {
                console.error('Error removing session from localStorage:', error);
            }
        }
        
        // Load all chat sessions
        async function loadChatSessions(initialSessionId = null, loadChatHistoryAfter = true) {
            try {
                const response = await fetch('/api/sessions');
                const data = await response.json();
                
                if (response.ok) {
                    // Clear existing sessions
                    chatSessionsList.innerHTML = '';
                    
                    if (data.sessions.length === 0) {
                        // No sessions available, show message
                        chatSessionsList.innerHTML = '<div class="sessions-loading">No chat sessions yet</div>';
                        
                        // Check if we're in the middle of deleting the last session
                        // If we are, don't create a new session here - let the delete handler do it
                        const deletingLastSession = chatMessages.innerHTML.includes('Deleting chat session');
                        
                        if (!deletingLastSession && loadChatHistoryAfter) {
                            // Create a new session automatically only if not at root path
                            if (window.location.pathname !== '/') {
                                await createNewSession();
                            }
                        }
                    } else {
                        // Add sessions to sidebar
                        data.sessions.forEach(session => {
                            // If we have an initial session ID from URL, use that to determine active session
                            const isActive = initialSessionId ? 
                                session.id === initialSessionId : 
                                session.id === data.current_session_id;
                                
                            addSessionItem(session, isActive);
                        });
                        
                        // If we have an initial session ID from URL, switch to that session
                        if (initialSessionId && initialSessionId !== data.current_session_id && loadChatHistoryAfter) {
                            await switchSession(initialSessionId);
                        } else if (loadChatHistoryAfter && data.current_session_id) {
                            // Load current chat history
                            loadChatHistory();
                        }
                        
                        // Save sessions to localStorage for offline access
                        localStorage.setItem('chat_sessions', JSON.stringify(data.sessions));
                        localStorage.setItem('current_session_id', data.current_session_id);
                    }
                } else {
                    console.error('Error loading chat sessions:', data.error);
                    chatSessionsList.innerHTML = '<div class="sessions-error">Failed to load sessions</div>';
                    
                    // Try to load sessions from localStorage
                    loadSessionsFromLocalStorage();
                }
            } catch (error) {
                console.error('Error loading chat sessions:', error);
                chatSessionsList.innerHTML = '<div class="sessions-error">Failed to load sessions</div>';
                
                // Try to load sessions from localStorage
                loadSessionsFromLocalStorage();
            }
        }
        
        // Show error message with retry option
        function showError(message, showRetry = false) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            
            let errorContent = `<p>${message}</p>`;
            
            if (showRetry) {
                errorContent += `
                    <button class="retry-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 2v6h-6"></path>
                            <path d="M3 12a9 9 0 0 1 15-6.7l3 2.7"></path>
                            <path d="M3 22v-6h6"></path>
                            <path d="M21 12a9 9 0 0 1-15 6.7l-3-2.7"></path>
                        </svg>
                        Retry
                    </button>
                `;
            }
            
            errorDiv.innerHTML = errorContent;
            
            // Clear previous errors
            const existingErrors = chatMessages.querySelectorAll('.error-message');
            existingErrors.forEach(err => err.remove());
            
            // Add to chat
            chatMessages.appendChild(errorDiv);
            
            // Scroll to error
            scrollToLatestMessage();
            
            // Add retry event listener if needed
            if (showRetry) {
                const retryBtn = errorDiv.querySelector('.retry-button');
                retryBtn.addEventListener('click', () => {
                    errorDiv.remove();
                    // Try to reload the current view
                    loadChatHistory();
                });
            }
        }

        // Show error with retry button
        function showRetryableError(errorMessage, originalMessage) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            
            errorDiv.innerHTML = `
                <p>Error: ${errorMessage}</p>
                <button class="retry-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 2v6h-6"></path>
                        <path d="M3 12a9 9 0 0 1 15-6.7l3 2.7"></path>
                        <path d="M3 22v-6h6"></path>
                        <path d="M21 12a9 9 0 0 1-15 6.7l-3-2.7"></path>
                    </svg>
                    Retry
                </button>
            `;
            
            // Add to chat
            chatMessages.appendChild(errorDiv);
            
            // Scroll to error
            scrollToLatestMessage();
            
            // Add retry event listener
            const retryBtn = errorDiv.querySelector('.retry-button');
            retryBtn.addEventListener('click', () => {
                // Remove the error message
                errorDiv.remove();
                
                // Re-queue the original message
                queueMessage(originalMessage);
            });
            
            return errorDiv;
        }

        // Update send button to call stopGeneration when in stop state
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = messageInput.value.trim();
            
            // If the send button is in stop generation state
            if (sendButton.classList.contains('stop-generation')) {
                // Abort the current request
                stopGeneration();
                return;
            }
            
            if (message) {
                if (isEditingMessage && messageBeingEdited) {
                    // Get the message ID
                    const messageId = messageBeingEdited.getAttribute('data-message-id');
                    
                    // Add updated message
                    addMessage(message, true, messageId);
                    
                    // Find the next bot message
                    let nextMessage = messageBeingEdited.nextElementSibling;
                    if (nextMessage && nextMessage.classList.contains('bot-message')) {
                        // Remove the old bot response
                        nextMessage.remove();
                    }
                    
                    // Reset editing state
                    isEditingMessage = false;
                    chatForm.classList.remove('editing-mode');
                    
                    // Reset send button
                    sendButton.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    `;
                    
                    // Clear input
                    messageInput.value = '';
                    
                    // Add to queue instead of sending directly
                    queueMessage(message);
                } else {
                    // Normal new message - don't add the message here as it's added in sendMessage
                    messageInput.value = '';
                    
                    // Add to queue instead of sending directly
                    queueMessage(message);
                }
                
                // Reset text input height if it was expanded
                messageInput.style.height = 'auto';
            }
        });

        // Save current chat session to localStorage
        function saveChatToLocalStorage() {
            try {
                const currentSessionId = getCurrentSessionId();
                if (!currentSessionId) return;
                
                // Get messages from the DOM
                const messages = [];
                const messageElements = chatMessages.querySelectorAll('.message');
                
                messageElements.forEach(messageEl => {
                    const isUser = messageEl.classList.contains('user-message');
                    const content = messageEl.querySelector('.message-content');
                    const timestamp = messageEl.querySelector('.message-timestamp');
                    const isoTime = timestamp ? timestamp.getAttribute('data-iso-time') : null;
                    
                    if (content && timestamp) {
                        messages.push({
                            isUser: isUser,
                            content: isUser ? content.textContent : content.innerHTML,
                            timestamp: timestamp.textContent,
                            isoTime: isoTime || new Date().toISOString() // Fallback to current time if no ISO time
                        });
                    }
                });
                
                // Save to localStorage
                localStorage.setItem(`chat_history_${currentSessionId}`, JSON.stringify(messages));
                
                // Save current session ID
                localStorage.setItem('current_session_id', currentSessionId);
                
                // Debug logging
                console.log(`Saved ${messages.length} messages for session ${currentSessionId}`);
            } catch (error) {
                console.error('Error saving chat to localStorage:', error);
            }
        }
        
        // Get current session ID
        function getCurrentSessionId() {
            const activeSession = document.querySelector('.session-item.active');
            return activeSession ? activeSession.getAttribute('data-session-id') : null;
        }
        
        // Load chat history for the current session
        async function loadChatHistory() {
            try {
                // Clear existing messages
                chatMessages.innerHTML = '<div class="loading-message">Loading messages...</div>';
                
                // Get the current session ID
                const currentSessionId = getCurrentSessionId();
                if (!currentSessionId) {
                    chatMessages.innerHTML = '';
                    return;
                }
                
                // Try to fetch from server first
                const response = await fetch('/api/history');
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Clear loading message
                    chatMessages.innerHTML = '';
                    
                    // If no messages, add welcome message
                    if (!data.history || data.history.length === 0) {
                        addMessage('{{ initial_message }}');
                        return;
                    }
                    
                    // Add messages to the UI
                    data.history.forEach(msg => {
                        if (msg.query) {
                            // Create timestamp object for user message (hidden from UI)
                            const userTimestamp = {
                                display: "",
                                iso: msg.user_iso_timestamp || msg.iso_timestamp || new Date().toISOString()
                            };
                            addMessage(msg.query, true, null, userTimestamp);
                        }
                        if (msg.response) {
                            // Create timestamp object for bot message (hidden from UI)
                            const botTimestamp = {
                                display: "",
                                iso: msg.iso_timestamp || new Date().toISOString()
                            };
                            addMessage(msg.response, false, null, botTimestamp);
                        }
                    });
                    
                    // Debug logging
                    console.log(`Loaded ${data.history ? data.history.length : 0} messages from server`);
                } else {
                    // If server request fails, try loading from localStorage
                    console.error('Failed to load chat history from server');
                    loadChatFromLocalStorage(currentSessionId);
                }
            } catch (error) {
                console.error('Error loading chat history:', error);
                
                // Try to load from localStorage as fallback
                const currentSessionId = getCurrentSessionId();
                if (currentSessionId) {
                    loadChatFromLocalStorage(currentSessionId);
                } else {
                    chatMessages.innerHTML = '';
                    addMessage('{{ initial_message }}');
                }
            }
        }
        
        // Load chat from localStorage
        function loadChatFromLocalStorage(sessionId) {
            try {
                const savedChat = localStorage.getItem(`chat_history_${sessionId}`);
                
                // Clear chat area
                chatMessages.innerHTML = '';
                
                if (savedChat) {
                    const messages = JSON.parse(savedChat);
                    
                    // Add messages to UI
                    messages.forEach(msg => {
                        // Pass the timestamp as the last parameter (hidden from UI)
                        const timestamp = msg.isoTime ? 
                            { iso: msg.isoTime, display: "" } : 
                            "";
                            
                        addMessage(msg.content, msg.isUser, null, timestamp);
                    });
                    
                    // Debug logging
                    console.log(`Loaded ${messages.length} messages from localStorage for session ${sessionId}`);
                } else {
                    // If no saved messages, add welcome message
                    addMessage('{{ initial_message }}');
                }
            } catch (error) {
                console.error('Error loading chat from localStorage:', error);
                chatMessages.innerHTML = '';
                addMessage('{{ initial_message }}');
            }
        }
        
        // Load sessions from localStorage when offline or server error
        function loadSessionsFromLocalStorage() {
            try {
                const savedSessions = localStorage.getItem('chat_sessions');
                const currentSessionId = localStorage.getItem('current_session_id');
                
                if (savedSessions) {
                    const sessions = JSON.parse(savedSessions);
                    
                    // Clear existing sessions list
                    chatSessionsList.innerHTML = '';
                    
                    if (sessions.length === 0) {
                        chatSessionsList.innerHTML = '<div class="sessions-loading">No chat sessions yet</div>';
                    } else {
                        // Add sessions to sidebar
                        sessions.forEach(session => {
                            addSessionItem(session, session.id === currentSessionId);
                        });
                    }
                    
                    // Load current chat
                    if (currentSessionId) {
                        loadChatFromLocalStorage(currentSessionId);
                    }
                } else {
                    chatSessionsList.innerHTML = '<div class="sessions-loading">No chat sessions yet</div>';
                }
            } catch (error) {
                console.error('Error loading sessions from localStorage:', error);
                chatSessionsList.innerHTML = '<div class="sessions-error">Failed to load sessions</div>';
            }
        }
    </script>
</body>
</html>